"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[355],{6790:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Returns a new Cooldown.","params":[{"name":"Time","desc":"The time property, for more info check the \\"Time\\" property.","lua_type":"number"},{"name":"AutoReset","desc":"Sets the AutoReset value to the boolean provided, please refer to [Cooldown.AutoReset]","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Cooldown\\r\\n"}],"function_type":"static","errors":[{"lua_type":"\\"No Time\\"","desc":"Happens when no Time property is provided."}],"source":{"line":167,"path":"src/Cooldown/init.lua"}},{"name":"Reset","desc":"Resets the debounce. Just like calling a sucessful :Run() with AutoReset set to true\\nIf a delay is provided, the debounce will be delayed by the provided number. A delay will only last once.\\nAn example would be:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal Debounce: Cooldown = Cooldown.new(2)\\nDebounce.AutoReset = false\\n\\nDebounce:Run(function()\\n\\tprint(\\"This will run\\")  -- prints\\nend)\\n\\nDebounce:Reset(1) -- We reset it and delay it by 1\\n\\nDebounce.OnReady:Wait() -- We wait 3 seconds instead of 2, because we delay it by 1.\\n-- You can think of delaying as adding time + delay which would be 2 + 1 in our case\\n-- Delaying will not change the time.\\n\\nDebounce:Run(function()\\n\\tprint(\\"This will run\\")  -- will print because the :Run will be ready.\\nend)\\n```","params":[{"name":"Delay","desc":"The amount of delay to add to the Time","lua_type":"number?"}],"returns":[{"desc":"The cooldown time + delay.","lua_type":"number"}],"function_type":"method","source":{"line":220,"path":"src/Cooldown/init.lua"}},{"name":"Run","desc":"Runs the given callback function if the passed time is higher than the Time property.\\nIf AutoReset is true, it will call :Reset() after a successful run.","params":[{"name":"Callback","desc":"The function that will be called on a successful run. Will yield.","lua_type":"() -> nil"}],"returns":[{"desc":"Returns a boolean indicating if the run was successful or not.","lua_type":"boolean"}],"function_type":"method","errors":[{"lua_type":"\\"No Callback\\"","desc":"Happens when no callback is provided."}],"yields":true,"source":{"line":251,"path":"src/Cooldown/init.lua"}},{"name":"RunIf","desc":"If the given Predicate (The First parameter) is true or returns true, it will call :Run() on itself.\\n\\n\\nAn example would be:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal Debounce = Cooldown.new(5)\\nDebounce.AutoReset = false\\n\\nDebounce:RunIf(true, function()\\n\\tprint(\\"This will run\\")  -- prints\\nend)\\n\\nDebounce:RunIf(false, function()\\n\\tprint(\\"This will not run\\")  -- does not print because the first parameter (Predicate) is false.\\nend)\\n```","params":[{"name":"Predicate","desc":"The boolean or function that returns a boolean indicating if :Run() will be called.","lua_type":"boolean | () -> boolean"},{"name":"Callback","desc":"The function that will be called on a successful run. Will yield.","lua_type":"() -> nil"}],"returns":[{"desc":"Returns a boolean indicating if the run was successful or not.","lua_type":"boolean"}],"function_type":"method","errors":[{"lua_type":"\\"No Predicate\\"","desc":"Happens when no Predicate, indicated by a boolean or boolean-returning function is provided."},{"lua_type":"\\"No Callback\\"","desc":"Happens when no callback is provided."}],"yields":true,"source":{"line":297,"path":"src/Cooldown/init.lua"}},{"name":"RunOrElse","desc":"if the :Run() will not be successful, it will instead call callback2. This won\'t reset the debounce.\\n\\n\\nAn example would be:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal Debounce = Cooldown.new(5)\\n\\nDebounce:RunOrElse(function()\\n\\tprint(\\"This will run\\")  -- prints\\nend, function()\\n\\tprint(\\"This will not print\\") -- doesn\'t print because the :Run() will be successful.\\nend)\\n\\nDebounce:RunOrElse(function()\\n\\tprint(\\"This will not run\\")  -- does not print because the debounce hasn\'t finished waiting.\\nend, function()\\n\\tprint(\\"This will run\\") -- will print because the :Run() failed.\\nend)\\n```","params":[{"name":"Callback","desc":"The function that will be called on a successful run. Will yield.","lua_type":"() -> nil"},{"name":"Callback2","desc":"The function that will be called on a unsuccessful run. Will yield.","lua_type":"() -> nil"}],"returns":[],"function_type":"method","errors":[{"lua_type":"\\"No Callback\\"","desc":"Happens when no Callback is provided."},{"lua_type":"\\"No Callback2\\"","desc":"Happens when no Callback2 is provided."}],"yields":true,"source":{"line":344,"path":"src/Cooldown/init.lua"}},{"name":"IsReady","desc":"Returns a boolean indicating if the Cooldown is ready to :Run().","params":[],"returns":[{"desc":"Indicates if the :Run() will be successful.","lua_type":"boolean"}],"function_type":"method","source":{"line":359,"path":"src/Cooldown/init.lua"}},{"name":"GetPassed","desc":"Returns a boolean indicating the passed time since the last :Run().","params":[{"name":"Clamped","desc":"If this is true, it will use math.clamp to make sure the value returned is min 0 and max the time.","lua_type":"boolean"}],"returns":[{"desc":"The passed time.","lua_type":"number"}],"function_type":"method","source":{"line":371,"path":"src/Cooldown/init.lua"}},{"name":"GetAlpha","desc":"Returns the time before the :Run() is ready in a value between 0-1.","params":[{"name":"Reversed","desc":"If true, will return alpha as 0 if fully ready to :Run() instead of 1.","lua_type":"boolean"}],"returns":[{"desc":"The passed time indicated by an alpha.","lua_type":"number"}],"function_type":"method","source":{"line":384,"path":"src/Cooldown/init.lua"}},{"name":"Is","desc":"Returns a boolean indicating if the given table is a Cooldown.","params":[{"name":"Object","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":392,"path":"src/Cooldown/init.lua"}},{"name":"Destroy","desc":"Destroys the Cooldown.","params":[],"returns":[],"function_type":"method","source":{"line":401,"path":"src/Cooldown/init.lua"}}],"properties":[{"name":"Time","desc":"The time property signifies how much time is needed to wait before using :Run()\\n\\nAn example would be:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal Debounce = Cooldown.new(5) -- The first parameter is the Time\\n-- Can be changed with Debounce.Time = 5\\n\\nDebounce:Run(function()\\n\\tprint(\\"This will run\\")  -- prints\\nend)\\n\\nDebounce:Run(function()\\n\\tprint(\\"This won\'t run\\")  -- won\'t print because the debounce hasn\'t finished waiting 5 seconds\\nend)\\n```\\n\\n:::note\\n\\tCalling :Run() when the debounce isn\'t ready won\'t yield.\\n:::","lua_type":"number","source":{"line":81,"path":"src/Cooldown/init.lua"}},{"name":"AutoReset","desc":"When AutoReset is on, the debounce will reset after a successful Run() call.\\n\\nAn example would be:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal Debounce = Cooldown.new(5)\\nDebounce.AutoReset = false\\n\\n-- Keep in mind you can also set the AutoReset by the second parameter in the constructor: Cooldown.new(5, false)\\n\\nDebounce:Run(function()\\n\\tprint(\\"This will run\\")  -- prints\\nend)\\n\\nDebounce:Run(function()\\n\\tprint(\\"This will still run\\")  -- still prints because AutoReset is false and the debounce did not reset\\nend)\\n\\nDebounce:Reset() -- Reset the debounce\\n```","lua_type":"boolean","source":{"line":107,"path":"src/Cooldown/init.lua"}}],"types":[{"name":"Cooldown","desc":"","fields":[{"name":"Time","lua_type":"number","desc":"The time of the debounce"},{"name":"LastActivation","lua_type":"number","desc":"The last time the debounce reset"},{"name":"AutoReset","lua_type":"boolean","desc":"Whether or not the debounce should reset after running."},{"name":"OnReady","lua_type":"RBXScriptSignal","desc":"Fires whenever the Cooldown can be be fired."},{"name":"OnSuccess","lua_type":"RBXScriptSignal","desc":"Fires whenever a :Run() was successful."},{"name":"OnFail","lua_type":"RBXScriptSignal","desc":"Fires whenever a :Run() fails."}],"source":{"line":55,"path":"src/Cooldown/init.lua"}}],"name":"Cooldown","desc":"Countdown is a Debounce utility which is meant to make it easier to create Debounce easily, with minimal effort.\\nBasic Usage:\\n```lua\\nlocal Cooldown = require(Path.Cooldown)\\n\\nlocal DebounceTime = 5\\nlocal Debounce = Cooldown.new(DebounceTime)\\n```","source":{"line":23,"path":"src/Cooldown/init.lua"}}')}}]);