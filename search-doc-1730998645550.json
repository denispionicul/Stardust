[{"title":"QueuePrompt","type":0,"sectionRef":"#","url":"/Stardust/api/QueuePrompt","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#properties","content":" "},{"title":"Running​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#Running","content":"since v1.4.0 &lt;/&gt; QueuePrompt.Running: boolean A boolean representing if the current function is running  "},{"title":"Priority​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#Priority","content":"This item is read only and cannot be modified. Read Only since v1.4.0 &lt;/&gt; QueuePrompt.Priority: number The queue's priority. "},{"title":"Functions​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#functions","content":" "},{"title":"SetPriority​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#SetPriority","content":"&lt;/&gt; QueuePrompt:SetPriority(Value: number) → QueuePrompt Sets the queue priority. When a queue goes to the next prompt, it'll pick the one with the highest Priority.  "},{"title":"Timeout​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#Timeout","content":"&lt;/&gt; QueuePrompt:Timeout(time: number) → QueuePrompt Disconnects the function after a given amount of time  "},{"title":"Destroy​","type":1,"pageTitle":"QueuePrompt","url":"/Stardust/api/QueuePrompt#Destroy","content":"&lt;/&gt; QueuePrompt:Destroy() → () Disconnects the function immediately "},{"title":"Queue","type":0,"sectionRef":"#","url":"/Stardust/api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#properties","content":" "},{"title":"Queue​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Queue","content":"since v1.4.0 &lt;/&gt; Queue.Queue: {QueuePrompt} A table of the current prompts that are in queue  "},{"title":"Emptied​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Emptied","content":"&lt;/&gt; Queue.Emptied: RBXScriptSignal  Fires whenever the queue runs out of functions. QueueClass.Emptied:Connect(function() print(&quot;Queue emptied!&quot;) end)   "},{"title":"Returned​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Returned","content":"since v1.1.0 &lt;/&gt; Queue.Returned: RBXScriptSignal  Fires whenever a function in the queue returns a value. QueueClass.Returned:Connect(function(...) print(&quot;Queue returned a value&quot; ) print(...) end)   "},{"title":"Switched​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Switched","content":"since v1.3.0 &lt;/&gt; Queue.Switched: RBXScriptSignal  Fires whenever the queue moves onto the next function. Gives the queue prompt as the parameter QueueClass.Switched:Connect(function(Prompt) print(&quot;Queue moved onto the next function.&quot;, Prompt.Priority) end)  "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue Returns a new queue.  "},{"title":"Add​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Add","content":"&lt;/&gt; Queue:Add( func: (T...) → ...any, ...: any ) → QueuePrompt Adds a function to the queue.  "},{"title":"PromiseAdd​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#PromiseAdd","content":"&lt;/&gt; Queue:PromiseAdd( func: (T...) → ...any, ...: any ) → Promise Adds a function to the queue, but instead of returning a QueuePrompt it returns a Promise. The promise resolves with whatever the function returned once the function has ran inside the queue. If the promise is canceled, it will remove itself from the queue.  "},{"title":"Stop​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Stop","content":"&lt;/&gt; Queue:Stop() → () Clears all current functions in the queue and empties it. The emptied event won't fire in here.  "},{"title":"Destroy​","type":1,"pageTitle":"Queue","url":"/Stardust/api/Queue#Destroy","content":"&lt;/&gt; Queue:Destroy() → () Destroys the queue. "},{"title":"Countdown","type":0,"sectionRef":"#","url":"/Stardust/api/Countdown","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#functions","content":" "},{"title":"Simple​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#Simple","content":"&lt;/&gt; Countdown.Simple( StartCount: number, CheckFunction: (Count: number) → boolean, Interval: number?, DecrementNumber: number?, StartsNow: boolean? ) → any Creates a simple timer that returns a promise. Every single interval (default of 1 second), the check function is ran. The check function will have as a parameter a Count, indicating the current count of the timer. The check function should return a boolean, indicating if it will keep running. A DecrementNumber can be provided (defaults to 1) which says how much the timer should decrease the count everytime the CheckFunction is ran. If StartNow is true, the check function will run immediately. The returned promise resolves once the timer reaches 0 and it can be canceled.  "},{"title":"new​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#new","content":"&lt;/&gt; Countdown.new( Interval: number, StartingCount: number ) → Countdown "},{"title":"Types","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown##","content":""},{"title":"​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#Countdown","content":"interface Countdown { Timer: Timer-- the Timer object, should be used for modifying things such as the Interval, TimeFunction, UpdateSignal and AllowDrift. Count: number-- The current number the countdown is at MaxCount: number-- The maximum the count can reach Increment: number-- The amount that the count decreases every tick OnFinish: Signal-- Fires whenever the count reaches 0 Tick: Signal&lt;number&gt;-- Same as the Timer.Tick property, but with the guarantee that it will fire after the count updates, it also returns the current count as a parameter. Started: Signal-- Fires whenever the :Start() or :StartNow() method is called. Stopped: Signal-- Fires whenever :Stop() is called (or the countdown finished). }  Creates a new countdown object.  "},{"title":"Stop​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#Stop","content":"&lt;/&gt; Countdown:Stop() → () Stops the countdown  "},{"title":"StartNow​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#StartNow","content":"&lt;/&gt; Countdown:StartNow() → () Starts the countdown and fires the .Tick signal immediately.  "},{"title":"Start​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#Start","content":"&lt;/&gt; Countdown:Start() → () Starts the countdown.  "},{"title":"Destroy​","type":1,"pageTitle":"Countdown","url":"/Stardust/api/Countdown#Destroy","content":"&lt;/&gt; Countdown:Destroy() → () Destroys the countdown instance. "},{"title":"SignalUtil","type":0,"sectionRef":"#","url":"/Stardust/api/SignalUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SignalUtil","url":"/Stardust/api/SignalUtil#functions","content":" "},{"title":"ConnectLimited​","type":1,"pageTitle":"SignalUtil","url":"/Stardust/api/SignalUtil#ConnectLimited","content":"&lt;/&gt; SignalUtil.ConnectLimited( Signal: SignalLike&lt;T...&gt;, Callback: (T...) → (), Amount: number ) → ConnectionLike Connects the event to the callback, automaticly disconnects after the event was fired an amount of times.  "},{"title":"ConnectUntil​","type":1,"pageTitle":"SignalUtil","url":"/Stardust/api/SignalUtil#ConnectUntil","content":"&lt;/&gt; SignalUtil.ConnectUntil( Signal: SignalLike&lt;T...&gt;, Callback: (T...) → (), Time: number ) → ConnectionLike Connects the event to the callback, automaticly disconnects after the Time amount of seconds is passed.  "},{"title":"ConnectStrict​","type":1,"pageTitle":"SignalUtil","url":"/Stardust/api/SignalUtil#ConnectStrict","content":"&lt;/&gt; SignalUtil.ConnectStrict( Signal: SignalLike&lt;T...&gt;, Callback: (T...) → boolean ) → ConnectionLike Connects the event to the callback, if the callback returns true, it will disconnect the event.  "},{"title":"FilterSignal​","type":1,"pageTitle":"SignalUtil","url":"/Stardust/api/SignalUtil#FilterSignal","content":"&lt;/&gt; SignalUtil.FilterSignal( Signal: SignalLike&lt;T...&gt; | BindableEvent , Filter: (T...) → boolean, SignalConstructor: (() → S)? ) → S | BindableEvent  Clones a signal and attaches a filter to it. When the original signal provided fires, the filter will be ran. If the filter returns true, then the copy is fired aswell, if not then it will be ignored. "},{"title":"Stater","type":0,"sectionRef":"#","url":"/Stardust/api/Stater","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#types","content":" "},{"title":"State​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#State","content":"&lt;/&gt; type State = (Stater | any) → boolean?  "},{"title":"Functions​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#new","content":"&lt;/&gt; Stater.new( States: {[string]: State&lt;T&gt;},-- The Table that will have all the States Tick: number?,-- Optional tick to be set. Return: T?-- Determines what to return in the first parameter of each state. ) → Stater&lt;T&gt; "},{"title":"Types","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater##","content":""},{"title":"​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#Stater","content":"interface Stater { States: {[string]: State}-- The Provided States Table, if theres a &quot;Init&quot; state then that function will execute each time the Stater Starts. Info: {any?}-- A table that you can add anything in, this is more recommended than directly inserting variables inside the object. Tick: number?-- The time it takes for the current state to be called again after a function is done. Default is 0 Return: any-- This is the thing that returns as the first parameter of every single state. Default is the Stater object itself. State: State-- The current state that the Stater is on. StateConfirmation: boolean-- If this is enabled, the state MUST return a boolean indicating if the function ran properly. Changed: RBXScriptSignal -- A signal that fires whenever the State changes. Returns Current State and Previous State StatusChanged: RBXScriptSignal -- Fired whenever the Stater starts or closes. Returns the current status as a boolean. StateRemoved: RBXScriptSignal -- A signal that fires whenever a state is added via the Stater:AddState() method. Returns the State Name. StateAdded: RBXScriptSignal -- A signal that fires whenever a state is removed via the Stater:RemoveState() method. Returns the State Name. }  Returns a new Stater Object. "},{"title":"Errors","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater##","content":"Type\tDescription&quot;No States&quot;\tHappens when no States are provided  "},{"title":"RemoveState​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#RemoveState","content":"&lt;/&gt; Stater:RemoveState( Name: string-- The name of the removing state. ) → () Removes a state inside the states table.  "},{"title":"AddState​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#AddState","content":"&lt;/&gt; Stater:AddState( Name: string,-- The name that the state will go by. State: State&lt;any&gt;-- The State function itself. ) → () Adds a state inside the states table. If there is a Start after the State name inside the States, that will play. If there is a End after the State name inside the States, that will play after the state changes. "},{"title":"Errors","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater##","content":"Type\tDescription&quot;Existing State&quot;\tHappens when the name of the state is already inside the table.  "},{"title":"GetCurrentState​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#GetCurrentState","content":"&lt;/&gt; Stater:GetCurrentState() → string? Returns the current state the Stater is on indicated by a string. If none then nil. This is currently the same as self.State.  "},{"title":"IsWorking​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#IsWorking","content":"&lt;/&gt; Stater:IsWorking() → boolean Returns a boolean indicating if the State currently is on.  "},{"title":"SetState​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#SetState","content":"&lt;/&gt; Stater:SetState( State: string-- The function name inside States represented by a string ) → () Returns a boolean indicating if the State currently is on. "},{"title":"Errors","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater##","content":"Type\tDescription&quot;No State&quot;\tHappens when no State is provided. &quot;Invalid State&quot;\tHappens when the state provided doesn't exist.  "},{"title":"Start​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#Start","content":"&lt;/&gt; Stater:Start( StartingState: string-- The function name inside States represented by a string, this state will be set at the start. ) → () Begins the Stater. "},{"title":"Errors","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater##","content":"Type\tDescription&quot;No State&quot;\tHappens when no State is provided.  "},{"title":"Stop​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#Stop","content":"&lt;/&gt; Stater:Stop() → () Stops the stater and its state.  "},{"title":"Destroy​","type":1,"pageTitle":"Stater","url":"/Stardust/api/Stater#Destroy","content":"&lt;/&gt; Stater:Destroy() → () Gets rid of the Stater Object. "},{"title":"Cooldown","type":0,"sectionRef":"#","url":"/Stardust/api/Cooldown","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#properties","content":" "},{"title":"Time​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Time","content":"&lt;/&gt; Cooldown.Time: number The time property signifies how much time is needed to wait before using :Run() An example would be: local Cooldown = require(Path.Cooldown) local Debounce = Cooldown.new(5) -- The first parameter is the Time -- Can be changed with Debounce.Time = 5 Debounce:Run(function() print(&quot;This will run&quot;) -- prints end) Debounce:Run(function() print(&quot;This won't run&quot;) -- won't print because the debounce hasn't finished waiting 5 seconds end) note Calling :Run() when the debounce isn't ready won't yield.   "},{"title":"AutoReset​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#AutoReset","content":"&lt;/&gt; Cooldown.AutoReset: boolean When AutoReset is on, the debounce will reset after a successful Run() call. An example would be: local Cooldown = require(Path.Cooldown) local Debounce = Cooldown.new(5) Debounce.AutoReset = false -- Keep in mind you can also set the AutoReset by the second parameter in the constructor: Cooldown.new(5, false) Debounce:Run(function() print(&quot;This will run&quot;) -- prints end) Debounce:Run(function() print(&quot;This will still run&quot;) -- still prints because AutoReset is false and the debounce did not reset end) Debounce:Reset() -- Reset the debounce  "},{"title":"Functions​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#functions","content":" "},{"title":"Simple​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Simple","content":"&lt;/&gt; Cooldown.Simple( Time: number, Function: (T...) → (R...) ) → (T...) → ( boolean, R... ) Adds a cooldown to a function. It returns a copy of the function that always returns a boolean first, which is true if the function ran or false if the function didn't run because of the cooldown.  "},{"title":"new​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#new","content":"&lt;/&gt; Cooldown.new( Time: number,-- The time property, for more info check the &quot;Time&quot; property. AutoReset: boolean?-- Sets the AutoReset value to the boolean provided, please refer to Cooldown.AutoReset ) → Cooldown "},{"title":"Types","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown##","content":""},{"title":"​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Cooldown","content":"interface Cooldown { Time: number-- The time of the debounce LastActivation: number-- The last time the debounce reset AutoReset: boolean-- Whether or not the debounce should reset after running. OnReady: RBXScriptSignal | Signal-- Fires whenever the Cooldown can be be fired. OnSuccess: RBXScriptSignal | Signal-- Fires whenever a :Run() was successful. OnFail: RBXScriptSignal | Signal-- Fires whenever a :Run() fails. }  Returns a new Cooldown. "},{"title":"Errors","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown##","content":"Type\tDescription&quot;No Time&quot;\tHappens when no Time property is provided.  "},{"title":"Reset​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Reset","content":"&lt;/&gt; Cooldown:Reset( Delay: number?-- The amount of delay to add to the Time ) → number-- The cooldown time + delay. Resets the debounce. Just like calling a sucessful :Run() with AutoReset set to true If a delay is provided, the debounce will be delayed by the provided number. A delay will only last once. An example would be: local Cooldown = require(Path.Cooldown) local Debounce: Cooldown = Cooldown.new(2) Debounce.AutoReset = false Debounce:Run(function() print(&quot;This will run&quot;) -- prints end) Debounce:Reset(1) -- We reset it and delay it by 1 Debounce.OnReady:Wait() -- We wait 3 seconds instead of 2, because we delay it by 1. -- You can think of delaying as adding time + delay which would be 2 + 1 in our case -- Delaying will not change the time. Debounce:Run(function() print(&quot;This will run&quot;) -- will print because the :Run will be ready. end)   "},{"title":"Activate​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Activate","content":"&lt;/&gt; Cooldown:Activate() → () Makes the cooldown ready again.  "},{"title":"Run​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Run","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Cooldown:Run( Callback: (Args...) → (), ...: any ) → boolean Runs the given callback function if the passed time is higher than the Time property. If AutoReset is true, it will call :Reset() after a successful run.  "},{"title":"RunIf​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#RunIf","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Cooldown:RunIf( Predicate: boolean | () → boolean, Callback: (Args...) → (), ...: any ) → boolean If the given Predicate (The First parameter) is true or returns true, it will call :Run() on itself. An example would be: local Cooldown = require(Path.Cooldown) local Debounce = Cooldown.new(5) Debounce.AutoReset = false Debounce:RunIf(true, function() print(&quot;This will run&quot;) -- prints end) Debounce:RunIf(false, function() print(&quot;This will not run&quot;) -- does not print because the first parameter (Predicate) is false. end)   "},{"title":"RunOrElse​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#RunOrElse","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Cooldown:RunOrElse( Callback: () → (), Callback2: () → () ) → () if the :Run() will not be successful, it will instead call callback2. This won't reset the debounce. An example would be: local Cooldown = require(Path.Cooldown) local Debounce = Cooldown.new(5) Debounce:RunOrElse(function() print(&quot;This will run&quot;) -- prints end, function() print(&quot;This will not print&quot;) -- doesn't print because the :Run() will be successful. end) Debounce:RunOrElse(function() print(&quot;This will not run&quot;) -- does not print because the debounce hasn't finished waiting. end, function() print(&quot;This will run&quot;) -- will print because the :Run() failed. end)   "},{"title":"Wrap​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Wrap","content":"&lt;/&gt; Cooldown:Wrap(Function: (T...) → R...) → WrapFuncReturn&lt;T...,R...&gt; Wraps a cooldown class to a function (similar to Cooldown.Simple). It returns a Cooldown class that when called, it will call Cooldown:Run() on the given function. When calling the cooldown class, the first return will always be a boolean before the returns. If the function succesfully runs, the boolean will be true.  "},{"title":"IsReady​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#IsReady","content":"&lt;/&gt; Cooldown:IsReady() → boolean Returns a boolean indicating if the Cooldown is ready to :Run().  "},{"title":"GetPassed​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#GetPassed","content":"&lt;/&gt; Cooldown:GetPassed( Clamped: boolean-- If this is true, it will use math.clamp to make sure the value returned is min 0 and max the time. ) → number Returns a boolean indicating the passed time since the last :Run().  "},{"title":"GetAlpha​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#GetAlpha","content":"&lt;/&gt; Cooldown:GetAlpha( Reversed: boolean-- If true, will return alpha as 0 if fully ready to :Run() instead of 1. ) → number Returns the time before the :Run() is ready in a value between 0-1.  "},{"title":"Destroy​","type":1,"pageTitle":"Cooldown","url":"/Stardust/api/Cooldown#Destroy","content":"&lt;/&gt; Cooldown:Destroy() → () Destroys the Cooldown. "}]